# usefull commands

## to get list of all actions
#fastlane actions

## to get list of parameters of action
#fastlane action ANY-ACTION
# example: fastlane action match


# USERNAME = ''
BUNDLE_ID = 'by.come.life.Lifebox'
APP_NAME = 'lifebox-LIFE'
# SCHEME = "Depo_LifeTech"
PROJECT = "Depo.xcodeproj"
TARGET = "Depo_LifeTech"
BUILD_FOLDER_NAME = "builds"
# TEAM_ID = ""
# DEV_NAME = "" #mayby need Team Name

TYPES = ["development", "appstore", "adhoc"]
CONFIGS = ["debug", "release", "adhoc"]
SCHEMES = ["PROD", "PREPROD", "TEST"]

# If you want to automatically update fastlane if a new version is available:
# update_fastlane

# This is the minimum version number required.
fastlane_version "2.19.1"

default_platform :ios

platform :ios do
	lane :beta_jenkins do
		begin
			jenkins_build()
		rescue => exception
			on_error(exception)
		end
	end

	lane :beta_jenkins_preprod do
		begin
			jenkins_build_preprod()
		rescue => exception
			on_error(exception)
		end
	end

  def update_fastlane_plugins
    sh("fastlane update_plugins")
  end

	def jenkins_build
		xcode_select "/Applications/Xcode.app"
		setup_jenkins
		bundle_install
		cocoapods
    update_fastlane_plugins()
    poeditor_download
		my_gym(scheme: "PROD")
		fabric
		slack_post
	end

	def jenkins_build_preprod
		xcode_select "/Applications/Xcode.app"
		setup_jenkins
		bundle_install
		cocoapods
    update_fastlane_plugins()
    poeditor_download

    build_number = get_build_number(xcodeproj: ".", target: TARGET)
    set_build_number(xcodeproj: ".", target: TARGET, new_number: build_number + "_preprod")

		my_gym(scheme: "PREPROD")
		fabric
		slack_post

    set_build_number(xcodeproj: ".", target: TARGET, new_number: build_number)
	end


	lane :beta_diawi do
		setup_jenkins
		my_gym(scheme: "PROD")
		diawi
	end

	lane :beta_fabric do
		my_gym(scheme: "PROD")
		fabric
		slack_post
		notify_about_completion
	end

  lane :beta_fabric_preprod do
    ## should be set localy(build lane), not in my_gym lane. slack_post could
    build_number = get_build_number(xcodeproj: ".", target: TARGET)
    set_build_number(xcodeproj: ".", target: TARGET, new_number: build_number + "_preprod")

    my_gym(scheme: "PREPROD")
    fabric
    slack_post
    notify_about_completion
    set_build_number(xcodeproj: ".", target: TARGET, new_number: build_number)
  end


  #--------------- build ipa ---------------

  desc "Create ipa"
  lane :my_gym do |options|
  	
    scheme = options[:scheme]

    if !SCHEMES.include?(scheme)
      # raise("scheme can be PROD, PREPROD or TEST")
      UI.user_error!("scheme can be PROD, PREPROD or TEST")
      # exit
    end

    gym(
      # configuration: config, #"Adhoc", # Defaults to 'Release'
      scheme: "Depo_LifeTech_" + scheme,
      silent: true, # Hide all information that's not necessary while building
      clean: false,
      output_directory: "./#{BUILD_FOLDER_NAME}",    # store the ipa in this folder
      output_name: "#{APP_NAME}.ipa",
      #output_directory: "path/to/dir", # Destination directory. Defaults to current directory.
      #output_name: "my-app.ipa",       # specify the name of the .ipa file to generate (including file extension)
      export_options: {
      	method: "ad-hoc"
        # ,
        # provisioningProfiles: { 
        #   "#{BUNDLE_ID}" => "ADHOC_LifeboxForTurkcell"
        # }
      }

    )
  end


  #--------------- distribute ---------------

  # https://dashboard.diawi.com/docs/apis/upload
  lane :diawi do
  	ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH]
    # time = Time.new
    diawiToken = 'rvA4lMxATOqmygUZmMgM7n5vchCnDkb5TJuZnVSibZ'
    filePath = "#{File.expand_path("..", Dir.pwd)}/#{BUILD_FOLDER_NAME}/#{APP_NAME}.ipa" # cd .. &&
    sh(
    	"curl -X POST https://upload.diawi.com/"\
    	" -F \"token=#{diawiToken}\""\
    	" -F \"file=@#{filePath}\""\
    	" -F \"find_by_udid=0\""\
    	" -F \"wall_of_apps=0\""\
    	" -F \"callback_emails=zdaecq@gmail.com\""
    )
  end

  desc "Distribute build via Fabric"
  lane :fabric do
  	ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH]
  	filePath = "#{File.expand_path("..", Dir.pwd)}/#{BUILD_FOLDER_NAME}/#{APP_NAME}.ipa"

  	crashlytics(
  		api_token: "74412d8a38e9c5b44ca9993298b0ec4cba26289b",
  		build_secret: "23466683fd868f8140731ca083851a229b69fe7c806515ab6cc300e32cd5f388",
  		ipa_path: filePath,
  		emails: ["lifetechqa@icloud.com",
  			"lifetechqa2@gmail.com",
  			"lifetechqa4@icloud.com",
  			"lifetechqa5@icloud.com",
  			"lifetechqa6@icloud.com", 
  			"6257515test@gmail.com"]
  	)
  end


  #--------------- notify ---------------

  desc "Post message to the #lifebox-ios-firengine slack channel"
  lane :slack_post do
  	version = get_build_number_from_plist(xcodeproj: PROJECT, target: TARGET)
  	slack(
  		message: "Build #{version} successfully released!",
  		success: true,
  		slack_url: "https://hooks.slack.com/services/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",
      # slack_url: "https://hooks.slack.com/services/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", #lifebox-ios-firengine
      payload: { 
      	"Build Date" => Time.new.to_s
      },
      default_payloads: []
    )
  end

  lane :notify_about_completion do
  	version = get_build_number_from_plist(xcodeproj: PROJECT, target: TARGET)
  	notification(subtitle: "Build distribution is finished", message: "#{version}")
  end

  def on_error(exception)
  	UI.user_error!("Build failed with exception : #{exception}")
  	slack(
  		message: "Build failed with exception : #{exception}",
  		success: false,
  		slack_url: "https://hooks.slack.com/services/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",
  		payload: { 
  			"Build Date" => Time.new.to_s
  		},
  		default_payloads: []
  	)
  end


  lane :poeditor_download do
    install_plugins
    for language in ["en", "uk", "tr", "ru", "ro", "es", "de", "ar"]
      poeditor_export(
        api_token: "be344da1ca0b150bafc6a74019ecaa12",
        project_id: "113239",
        export_format: "apple_strings",
        language: language,
        output_path: "./Depo/App/Resources/#{language}.lproj/OurLocalizable.strings"
      )
    end
  end


#--------------------- build_number functions ---------------------

  lane :test_get_build_number do
    build_number = get_build_number_from_plist(xcodeproj: "Depo.xcodeproj", scheme: "Depo_LifeTech_PROD")
    puts "version: #{build_number}"

    increment_build_number_in_plist(build_number: build_number + "_preprod", scheme: "Depo_LifeTech_PROD")

    build_number = get_build_number_from_plist(xcodeproj: "Depo.xcodeproj", scheme: "Depo_LifeTech_PROD")
    puts "new version: #{build_number}"
  end

  lane :test_get_build_number_my do
    build_number = get_build_number(xcodeproj: ".", target: TARGET)
    puts "version: #{build_number}"

    set_build_number(xcodeproj: ".", target: TARGET, new_number: build_number + "_preprod")

    build_number = get_build_number(xcodeproj: ".", target: TARGET)
    puts "new version: #{build_number}"
  end

  def get_build_number(params)
    folder = params[:xcodeproj] ? File.join(params[:xcodeproj], '..') : '.'
    target_name = params[:target]
    configuration = params[:configuration]

    # Get version_number
    project = get_project!(folder)
    target = get_target!(project, target_name)
    plist_file = get_plist!(folder, target, configuration)
    version_number = get_version_number!(plist_file)

    # Store the number in the shared hash
    Actions.lane_context[SharedValues::VERSION_NUMBER] = version_number

    # Return the version number because Swift might need this return value
    return version_number
  end

  def set_build_number(params)
    folder = params[:xcodeproj] ? File.join(params[:xcodeproj], '..') : '.'
    target_name = params[:target]
    configuration = params[:configuration]
    new_number = params[:new_number]

    # Get version_number
    project = get_project!(folder)
    target = get_target!(project, target_name)
    plist_file = get_plist!(folder, target, configuration)
    save_version_number!(plist_file, new_number)

    # Store the number in the shared hash
    Actions.lane_context[SharedValues::VERSION_NUMBER] = new_number
  end

  def self.get_project!(folder)
    require 'xcodeproj'
    project_path = Dir.glob("#{folder}/*.xcodeproj").first
    if project_path
      return Xcodeproj::Project.open(project_path)
    else
      UI.user_error!("Unable to find Xcode project in folder: #{folder}")
    end
  end

  def self.get_target!(project, target_name)
    targets = project.targets

    # Prompt targets if no name
    unless target_name

      # Gets non-test targets
      non_test_targets = targets.reject do |t|
        # Not all targets respond to `test_target_type?`
        t.respond_to?(:test_target_type?) && t.test_target_type?
      end

      # Returns if only one non-test target
      if non_test_targets.count == 1
        return targets.first
      end

      options = targets.map(&:name)
      target_name = UI.select("What target would you like to use?", options)
    end

    # Find target
    target = targets.find do |t|
      t.name == target_name
    end
    UI.user_error!("Cannot find target named '#{target_name}'") unless target

    target
  end

  def self.get_plist!(folder, target, configuration = nil)
    plist_files = target.resolved_build_setting("INFOPLIST_FILE")
    plist_files_count = plist_files.values.compact.uniq.count

    # Get plist file for specified configuration
    # Or: Prompt for configuration if plist has different files in each configurations
    # Else: Get first(only) plist value
    if configuration
      plist_file = plist_files[configuration]
    elsif plist_files_count > 1
      options = plist_files.keys
      selected = UI.select("What build configuration would you like to use?", options)
      plist_file = plist_files[selected]
    else
      plist_file = plist_files.values.first
    end

    # $(SRCROOT) is the path of where the XcodeProject is
    # We can just set this as empty string since we join with `folder` below
    if plist_file.include?("$(SRCROOT)/")
      plist_file.gsub!("$(SRCROOT)/", "")
    end

    plist_file = File.absolute_path(File.join(folder, plist_file))
    UI.user_error!("Cannot find plist file: #{plist_file}") unless File.exist?(plist_file)

    plist_file
  end

  def self.get_version_number!(plist_file)
    plist = Xcodeproj::Plist.read_from_path(plist_file)
    UI.user_error!("Unable to read plist: #{plist_file}") unless plist
    return plist["CFBundleVersion"]
  end

  def self.save_version_number!(plist_file, new_number)
    plist = Xcodeproj::Plist.read_from_path(plist_file)
    UI.user_error!("Unable to read plist: #{plist_file}") unless plist

    plist["CFBundleVersion"] = new_number
    Xcodeproj::Plist.write_to_path(plist, plist_file)
  end
end
